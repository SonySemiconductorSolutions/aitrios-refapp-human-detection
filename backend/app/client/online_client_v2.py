# Copyright 2025 Sony Semiconductor Solutions Corp.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0
import base64
import datetime
import logging
import urllib
from tempfile import TemporaryDirectory
from time import sleep
from time import time
from typing import Optional

from app.client.client_interface import ClientInferface
from app.client.client_interface import StatusResponse
from app.config.get_console_settings import get_console_settings
from app.schemas.configuration import ConfigurationV2
from app.schemas.device import Device
from app.schemas.device import Devices
from app.schemas.insight import ImageAndInference
from app.schemas.insight import ImageDirectories
from app.schemas.insight import Inference
from app.utils.auth import get_token
from app.utils.timestamp import convert_iso_timestamp_to_numeric
from app.utils.timestamp import convert_numeric_timestamp_to_iso
from console_v2_api_client import ApiClient
from console_v2_api_client import ApiException
from console_v2_api_client import Configuration
from console_v2_api_client import DeviceCommandApi
from console_v2_api_client import InsightApi
from console_v2_api_client import ManageDevicesApi
from console_v2_api_client.models.device import Device as DeviceConsoleV2
from console_v2_api_client.models.device import Device as DeviceV2Info
from console_v2_api_client.models.execute_command_json_body import (
    ExecuteCommandJsonBody,
)
from console_v2_api_client.models.execute_device_command200_response import (
    ExecuteDeviceCommand200Response,
)
from console_v2_api_client.models.get_property200_response import GetProperty200Response
from console_v2_api_client.models.inferenceresults_get200_response import (
    InferenceresultsGet200Response,
)
from console_v2_api_client.models.update_configuration_json_body import (
    UpdateConfigurationJsonBody,
)
from console_v2_api_client.models.update_device_configuration200_response import (
    UpdateDeviceConfiguration200Response,
)
from fastapi import HTTPException
from pydantic import ValidationError


logger = logging.getLogger(__name__)


def _remove_empty_entries(dictionary: any) -> any:
    if not isinstance(dictionary, dict):
        return dictionary
    return {k: _remove_empty_entries(v) for k, v in dictionary.items() if v is not None}


def _process_configuration_for_sending(configuration: ConfigurationV2) -> dict:
    json_configuration = configuration.model_dump()
    return _remove_empty_entries(json_configuration)


class OnlineConsoleClientV2(ClientInferface):
    NUM_RETRIES = 10

    def __init__(self, timeout=None):
        super().__init__(timeout)
        self.__api_client = None
        self.token_expiry = time()

    def _get_client(self):
        """
        Get autogenerated API Client to interact with Online Console v2

        Returns:
            ApiClient: Python API Client
        """
        try:
            logger.debug("Attempting to create Online Console API v2 client.")
            (
                console_endpoint,
                client_id,
                client_secret,
                portal_authorization_endpoint,
            ) = get_console_settings()
            access_token, expires_in = get_token(
                client_id=client_id,
                client_secret=client_secret,
                portal_authorization_endpoint=portal_authorization_endpoint,
            )

            self.token_expiry = time() + expires_in - 10  # Add a safety buffer

            configuration = Configuration(host=console_endpoint)
            api_client = ApiClient(
                configuration=configuration,
                header_name="Authorization",
                header_value=f"Bearer {access_token}",
            )
            logger.info("Online Console API v2 client successfully created.")

            return api_client
        except Exception as e:
            logger.error(
                f"Failed to create Online Console API v2 client: {e}", exc_info=True
            )
            raise HTTPException(
                status_code=500, detail=f"Unable to create API client: {str(e)}"
            )

    def get_client(self):
        if self.__api_client is None or time() >= self.token_expiry:
            logger.info("Initializing Online Console API v2 client connection.")
            self.__api_client = self._get_client()
        return self.__api_client

    def reload_client(self):
        logger.info("Reloading Online Console API client connection.")
        self.__api_client = self._get_client()

    def get_devices(self) -> Devices:
        logger.debug("Fetching device list from Online Console.")
        try:
            api_instance = ManageDevicesApi(self.get_client())
            response = api_instance.get_devices()
            device_list = [
                Device(
                    device_id=device.device_id,
                    device_name=device.device_name,
                    connection_state=device.connection_state,
                )
                for device in response.devices
            ]
            logger.info(f"Successfully fetched {len(device_list)} devices.")
            return Devices(devices=device_list)
        except ApiException as api_error:
            logger.error(
                f"API Error while fetching devices: {api_error}", exc_info=True
            )
            raise

    def get_device(self, device_id: str) -> Device:
        def _get_model_version_list(_device_info: DeviceConsoleV2) -> list[str]:
            return_list = []
            for chip_info in _device_info.var_property.state["device_info"]["chips"]:
                if chip_info["name"] != "sensor_chip":
                    continue
                for model in chip_info["ai_models"]:
                    if model["version"] != "":
                        return_list.append(model["version"])
            return return_list

        try:
            logger.debug(f"Fetching details for device ID {device_id}.")
            api_instance = ManageDevicesApi(self.get_client())
            response: DeviceConsoleV2 = api_instance.get_device(
                device_id=device_id, _request_timeout=self.timeout
            )
        except ApiException as api_error:
            logger.error(
                f"API Error while fetching device with ID {device_id}: {api_error}",
                exc_info=True,
            )
            raise Exception(
                f"API Error while fetching device with ID {device_id}: {api_error}"
            )

        try:
            if "device_info" not in response.var_property.state:
                raise TypeError("Device is not a v2 device.")
            device = Device(
                device_id=device_id,
                device_name=response.device_name,
                connection_state=response.connection_state,
                models=_get_model_version_list(response),
                application=[module.module_name for module in response.modules],
                inference_status=response.var_property.state["device_states"][
                    "process_state"
                ],
            )

            logger.info(f"Successfully fetched details for device ID {device_id}.")
            return device
        except AttributeError as attr_error:
            logger.error(f"Response attribute error: {attr_error}", exc_info=True)
            raise Exception(f"Response attribute error: {attr_error}")
        except TypeError as type_error:
            logger.error(f"Version mismatch: {type_error}", exc_info=True)
            raise Exception(f"Version mismatch: {type_error}")
        except Exception as error:
            logger.error(f"Unexpected Error during processing: {error}", exc_info=True)
            raise Exception(f"Unexpected Error during processing: {error}")

    def _get_module_id_from_device(self, device_id: str) -> str:
        manage_device_api: ManageDevicesApi = ManageDevicesApi(self.get_client())

        try:
            device_info: DeviceV2Info = manage_device_api.get_device(
                device_id=device_id
            )
        except ApiException as api_error:
            logger.error(
                f"Error while retrieving device with ID {device_id}: {api_error}"
            )
            raise Exception(
                f"Error while retrieving device with ID {device_id}: {api_error}"
            )

        return device_info.modules[0].module_id

    def get_configuration(self, device_id: str) -> ConfigurationV2:
        module_id: str = self._get_module_id_from_device(device_id=device_id)

        device_command_api: DeviceCommandApi = DeviceCommandApi(self.get_client())
        try:
            module_info: GetProperty200Response = device_command_api.get_property(
                device_id=device_id, module_id=module_id
            )
        except ApiException as api_error:
            logger.error(
                f"Error while retrieving property from device {device_id} with ID {module_id}: {api_error}"
            )
            raise Exception(
                f"Error while retrieving property from device {device_id} with ID {module_id}: {api_error}"
            )
        try:
            validatedConfig = ConfigurationV2.model_validate(
                module_info.var_property.state
            )
        except ValidationError as validation_error:
            logger.error(
                f"Missing / Unexpected fields in device configuration: device {device_id} with ID {module_id}: {validation_error}"  # include pydantic error details in console log
            )
            raise Exception(
                f"Missing / Unexpected fields in device configuration: device {device_id} with ID {module_id}"
            )

        return validatedConfig

    async def update_configuration(
        self, device_id: str, configuration: ConfigurationV2
    ) -> StatusResponse:
        device_command_api: DeviceCommandApi = DeviceCommandApi(self.get_client())

        module_id: str = self._get_module_id_from_device(device_id=device_id)

        json_configuration = _process_configuration_for_sending(configuration)

        return StatusResponse(
            status=device_command_api.update_module_configuration(
                device_id=device_id,
                module_id=module_id,
                update_configuration_json_body=UpdateConfigurationJsonBody(
                    configuration=json_configuration
                ),
                _request_timeout=self.timeout,
            ).result
        )

    async def set_configuration(
        self, device_id: str, configuration: ConfigurationV2
    ) -> StatusResponse:
        raise ApiException("Online Console V2 does not support this endpoint")

    def get_direct_image(self, device_id: str) -> str:
        try:
            response: ExecuteDeviceCommand200Response = DeviceCommandApi(
                self.get_client()
            ).execute_device_command(
                device_id=device_id,
                execute_command_json_body=ExecuteCommandJsonBody(
                    command_name="direct_get_image",
                    parameters={
                        "crop_h_offset": 0,
                        "crop_v_offset": 0,
                        "crop_h_size": 2028,
                        "crop_v_size": 1520,
                        "sensor_name": "IMX500",
                    },
                ),
            )
        except ApiException as api_error:
            logger.error(
                f"Error while fetching direct image from device with ID {device_id}: {api_error}"
            )
            raise Exception(
                f"API error while retrieving direct image from device id {device_id}: {api_error}"
            )

        error_msg = None
        if response.result != "SUCCESS":
            error_msg = response.result

        image = response.command_response["image"]
        if len(image) == 0:
            error_msg = "Image received is empty"

        if error_msg is not None:
            raise Exception(
                f"Error while fetching direct image from device with ID {device_id}: {error_msg}"
            )

        return image

    def get_latest_data(
        self, device_id: str, get_image: bool = False
    ) -> tuple[Optional[str], dict[str, str]]:
        logger.debug(
            f"Fetching latest data for device ID '{device_id}'. Get image: {get_image}"
        )
        try:
            insight_api = InsightApi(self.get_client())

            response: InferenceresultsGet200Response = insight_api.inferenceresults_get(
                devices=[device_id], limit=1, _request_timeout=self.timeout
            )

            inference = {
                "timestamp": None,
                "content": None,
            }
            if response.inferences is not None and len(response.inferences) > 0:
                timestamp_iso = response.inferences[0].inferences[0].t
                inference = {
                    "timestamp": convert_iso_timestamp_to_numeric(timestamp_iso),
                    "content": response.inferences[0].inferences[0].o,
                }

            image_content: str | None = None
            if get_image:
                image_name = inference["timestamp"]

                prev_configuration: ConfigurationV2 = self.get_configuration(device_id)
                subdirectory_name = prev_configuration.edge_app.common_settings.port_settings.input_tensor.path.split(
                    "/"
                )[
                    -1
                ]
                image_url = None
                for _ in range(OnlineConsoleClientV2.NUM_RETRIES):
                    image_urls = [
                        x.sas_url
                        for x in insight_api.get_images(
                            device_id=device_id,
                            sub_directory_name=subdirectory_name,
                            name_starts_with=image_name,
                        ).data
                    ]
                    if len(image_urls) > 0:
                        image_url = image_urls[-1]
                        break
                    sleep(0.1)

                if image_url is None:
                    raise Exception(
                        f"Image {image_name} not found in directory {subdirectory_name}"
                    )

                with TemporaryDirectory() as tmpdir_path:
                    image_filepath: str = tmpdir_path + f"/{image_name}.png"
                    urllib.request.urlretrieve(image_url, image_filepath)
                    with open(image_filepath, "rb") as f:
                        image_content = base64.b64encode(f.read()).decode("utf-8")

            logger.info(
                f"Successfully retrieved image and inference data for device ID '{device_id}'"
            )
            return image_content, inference
        except ApiException as api_error:
            logger.error(
                f"API error while retrieving data from device id {device_id}: {api_error}",
                exc_info=True,
            )
            raise Exception(
                f"API error while retrieving data from device id {device_id}: {api_error}"
            )

    def _update_process_state(
        self, _device_id: str, _module_id: str, _process_state: int
    ) -> UpdateDeviceConfiguration200Response:
        device_command_api: DeviceCommandApi = DeviceCommandApi(self.get_client())

        configuration = {
            "edge_app": {"common_settings": {"process_state": _process_state}}
        }

        return device_command_api.update_module_configuration(
            device_id=_device_id,
            module_id=_module_id,
            update_configuration_json_body=UpdateConfigurationJsonBody(
                configuration=configuration
            ),
            _request_timeout=self.timeout,
        )

    def _check_input_tensor_path_follows_convention(
        self, folder_path: str, device_id: str
    ) -> bool:
        folder_path_elements = folder_path.split("/")
        if len(folder_path_elements) != 3:
            return False

        folder_path_device_id = folder_path_elements[0]
        folder_path_image_element = folder_path_elements[1]
        folder_path_subfolder = folder_path_elements[2]

        if (
            folder_path_device_id != device_id
            or folder_path_image_element != "image"
            or folder_path_subfolder == ""
        ):
            return False

        return True

    def _validate_and_adapt_input_tensor_path(
        self, folder_path: str, device_id: str
    ) -> str:
        curr_date = datetime.datetime.now().strftime("%Y%m%d-%H%M%S%f")

        if folder_path is None or folder_path == "":
            return f"{device_id}/image/{curr_date}"

        folder_path_elements = folder_path.split("/")
        if not self._check_input_tensor_path_follows_convention(folder_path, device_id):
            # Verification that the images path follows the expected format of {device_id}/image/{subfolder}
            return f"{device_id}/image/{curr_date}"
        else:
            prev_folder_parent = "/".join(folder_path_elements[:-1])
            try:
                datetime.datetime.strptime(
                    folder_path.split("/")[-1], "%Y%m%d-%H%M%S%f"
                )

                # If the image subfolder is a date, replace it with the current one
                return f"{prev_folder_parent}/{curr_date}"
            except ValueError:
                # Otherwise, return the path as it is
                return folder_path

    def start_upload_inference_data(
        self, device_id: str, get_image: bool = False
    ) -> StatusResponse:

        logger.debug(
            f"Starting upload inference data for device ID '{device_id}'. Get image: {get_image}"
        )
        try:
            module_id: str = (
                ManageDevicesApi(self.get_client())
                .get_device(device_id=device_id)
                .modules[0]
                .module_id
            )

            # Getting current configuration to be updated
            device_command_api: DeviceCommandApi = DeviceCommandApi(self.get_client())

            if get_image:
                prev_configuration: ConfigurationV2 = self.get_configuration(device_id)
                prev_folder = (
                    prev_configuration.edge_app.common_settings.port_settings.input_tensor.path
                )
                new_inference_folder = self._validate_and_adapt_input_tensor_path(
                    prev_folder, device_id=device_id
                )

                configuration = {
                    "edge_app": {
                        "common_settings": {
                            "port_settings": {
                                "input_tensor": {
                                    "path": new_inference_folder,
                                    "enabled": True,
                                }
                            }
                        }
                    }
                }

            else:
                configuration = {
                    "edge_app": {
                        "common_settings": {
                            "port_settings": {"input_tensor": {"enabled": False}}
                        }
                    }
                }

            # Start inference
            configuration["edge_app"]["common_settings"]["process_state"] = 2

            response = device_command_api.update_module_configuration(
                device_id=device_id,
                module_id=module_id,
                update_configuration_json_body=UpdateConfigurationJsonBody(
                    configuration=configuration
                ),
                _request_timeout=self.timeout,
            )

            insight_api = InsightApi(self.get_client())
            latest_inference_id: str = (
                insight_api.inferenceresults_get(
                    devices=[device_id], limit=1, _request_timeout=self.timeout
                )
                .inferences[0]
                .id
            )

            start_time = time()
            time_out_secs = 60
            while (
                latest_inference_id
                == insight_api.inferenceresults_get(
                    devices=[device_id], limit=1, _request_timeout=self.timeout
                )
                .inferences[0]
                .id
            ):
                logger.info("Waiting for the device to start...")
                if time() - start_time > time_out_secs:
                    raise Exception("Timeout while waiting for device to start.")

            logger.debug(
                f"[start_upload_inference_data] Device started, status response: {response.result}"
            )
            return StatusResponse(status=response.result)
        except ApiException as api_error:
            logger.error(
                f"API error while starting to upload inference data: {api_error}",
                exc_info=True,
            )
            raise Exception(
                f"API error while starting to upload inference data: {api_error}"
            )

    def stop_upload_inference_data(self, device_id: str) -> StatusResponse:
        logger.debug(f"Stopping upload inference data for device ID '{device_id}'.")
        try:
            manage_devices_api = ManageDevicesApi(self.get_client())
            device_info: DeviceConsoleV2 = manage_devices_api.get_device(
                device_id=device_id
            )

            response = self._update_process_state(
                _device_id=device_id,
                _module_id=device_info.modules[0].module_id,
                _process_state=1,
            )
            logger.info(
                f"Successfully stopped upload inference data for device ID '{device_id}'."
            )
            if isinstance(response.result, str):
                return StatusResponse(status=response.result)
            return StatusResponse(status=response.result)
        except ApiException as api_error:
            logger.error(
                f"API error while stopping to upload inference data: {api_error}",
                exc_info=True,
            )
            raise Exception(
                f"API error while stopping to upload inference data: {api_error}"
            )

    def delete_device_data(self, device_id: str) -> StatusResponse:
        """Deletes all image directories and inference data related to the given device."""
        logger.debug(f"Initiating deletion of all data from device '{device_id}'.")
        try:
            insight_api = InsightApi(self.get_client())

            self._delete_image_directories(insight_api, device_id)
            self._delete_inference_results(insight_api, device_id)

            logger.info(f"Successfully deleted all data for device {device_id}")
            return StatusResponse(status="Success")
        except ApiException as api_error:
            logger.error(f"API error while deleting data from {device_id}: {api_error}")
            raise Exception(
                f"API error while deleting data from {device_id}: {api_error}"
            )

    def _delete_image_directories(self, insight_api: InsightApi, device_id: str):
        """Deletes all image directories for the specified device."""
        response = insight_api.get_image_directories(
            device_id, _request_timeout=self.timeout
        )

        if not response or not response[0].devices:
            logger.debug(f"No image directories found for device {device_id}")
            return

        image_dirs = response[0].devices[0].image
        logger.debug(
            f"Found {len(image_dirs)} image directories for deletion on {device_id}"
        )

        for sub_directory in image_dirs:
            insight_api.delete_images(
                device_id=device_id,
                sub_directory_name=sub_directory,
                delete_images_json_body={"directory_deletion": "1"},
                _request_timeout=self.timeout,
            )
            logger.debug(f"Deleted image directory '{sub_directory}' from {device_id}")

    def _delete_inference_results(self, insight_api: InsightApi, device_id: str):
        """Deletes all inference results for the specified device in batches."""
        batch_size = 100

        while True:
            inferences: InferenceresultsGet200Response = (
                insight_api.inferenceresults_get(
                    devices=[device_id], limit=batch_size, _request_timeout=self.timeout
                )
            )
            if not inferences.inferences:
                logger.debug(
                    f"No more inference results to delete for device {device_id}"
                )
                break

            item_ids = [i.id for i in inferences.inferences]
            insight_api.delete_inference_results(
                device_id=device_id, item_ids=",".join(item_ids)
            )
            logger.debug(f"Deleted {len(item_ids)} inference results for {device_id}")

    def get_image_directories(self, device_id: str) -> ImageDirectories:
        logger.debug("Fetching directory list from Online Console.")
        try:
            api_instance = InsightApi(self.get_client())
            response = api_instance.get_image_directories(device_id=device_id)
            directories = response[0].devices[0].image
            logger.info(
                f"Successfully fetched {len(directories)} directories for device ID '{device_id}'."
            )
            return ImageDirectories(directories=directories)
        except ApiException as api_error:
            logger.error(
                f"API Error while fetching image directories of {device_id}: {api_error}"
            )
            raise Exception(
                f"API Error while fetching image directories of {device_id}: {api_error}"
            )

    def get_images_and_inferences(
        self,
        device_id: str,
        sub_directory_name: str,
    ) -> list[ImageAndInference]:
        logger.info(f"Fetching uploaded inferences for device ID '{device_id}'.")

        try:
            insight_api = InsightApi(self.get_client())
            use_pagination = False
            continuation_token = None
            limit = 256

            collection = []

            while True:
                response = insight_api.get_images(
                    device_id=device_id,
                    sub_directory_name=sub_directory_name,
                    limit=limit,
                    starting_after=continuation_token if use_pagination else None,
                    _request_timeout=self.timeout,
                )

                for data in response.data:
                    numeric_timestamp = data.name.split(".")[0]
                    image_url = data.sas_url

                    collection.append(
                        {
                            "timestamp": numeric_timestamp,
                            "image": image_url,
                            "inference": None,
                        }
                    )

                if collection:
                    from_datetime_iso = convert_numeric_timestamp_to_iso(
                        collection[0]["timestamp"]
                    )
                    to_datetime_iso = convert_numeric_timestamp_to_iso(
                        collection[-1]["timestamp"]
                    )

                    response = insight_api.inferenceresults_get(
                        devices=[device_id],
                        from_datetime=from_datetime_iso,
                        to_datetime=to_datetime_iso,
                        limit=limit,
                        _request_timeout=self.timeout,
                    )

                    # Assign corresponding by matching inference timestamps with image timestamps in numeric fortmat
                    inference_dict = {}
                    if response.inferences:
                        for inferences in response.inferences:
                            inference = inferences.inferences[0].o
                            timestamp = inferences.inferences[0].t
                            inference_timestamp = convert_iso_timestamp_to_numeric(
                                timestamp
                            )
                            inference_dict[inference_timestamp] = {
                                "inference": inference,
                            }

                    for data in collection:
                        image_timestamp = data["timestamp"]
                        if image_timestamp in inference_dict:
                            data["inference"] = inference_dict[image_timestamp][
                                "inference"
                            ]

                if use_pagination and response.continuation_token:
                    continuation_token = response.continuation_token
                else:
                    break

            return collection
        except ApiException as api_error:
            error_message = f"API error while retrieving inference and image data from device id {device_id} : {api_error}"
            logger.error(error_message, exc_info=True)
            raise Exception(error_message)

    def get_inferences(
        self,
        device_id: str,
        from_datetime: datetime.datetime,
        to_datetime: datetime.datetime,
        order_by: Optional[str] = "ASC",
    ) -> list[Inference]:
        logger.debug(
            f"Fetching inference results for device ID '{device_id}' from {from_datetime} to {to_datetime} with order '{order_by}'"
        )

        try:
            insight_api = InsightApi(self.get_client())
            use_pagination = False
            continuation_token = None
            limit = 256

            inference_list = []

            while True:
                from_datetime_iso = from_datetime.replace(tzinfo=None).isoformat(
                    timespec="milliseconds"
                )
                to_datetime_iso = to_datetime.replace(tzinfo=None).isoformat(
                    timespec="milliseconds"
                )

                response = insight_api.inferenceresults_get(
                    devices=[device_id],
                    from_datetime=from_datetime_iso,
                    to_datetime=to_datetime_iso,
                    starting_after=continuation_token if use_pagination else None,
                    limit=limit,
                    _request_timeout=self.timeout,
                )

                if response.inferences:
                    for inferences in response.inferences:
                        if inferences.inferences and len(inferences.inferences) > 0:
                            inference_data = {
                                "timestamp": convert_iso_timestamp_to_numeric(
                                    inferences.inferences[0].t
                                ),
                                "inference": inferences.inferences[0].o,
                            }
                            inference_list.append(inference_data)

                if use_pagination and response.continuation_token:
                    continuation_token = response.continuation_token
                else:
                    break

            if order_by == "ASC":
                inference_list.reverse()

            logger.info(
                f"Successfully retrieved inference records from {from_datetime} to {to_datetime} for device ID '{device_id}'"
            )
            return inference_list

        except ApiException as api_error:
            error_message = f"API error while retrieving inference data from {from_datetime} to {to_datetime} from device id {device_id} : {api_error}"
            logger.error(error_message, exc_info=True)
            raise Exception(error_message)
